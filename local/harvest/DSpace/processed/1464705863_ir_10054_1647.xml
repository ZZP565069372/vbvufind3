<oai_dc:dc xmlns:oai_dc="http://www.openarchives.org/OAI/2.0/oai_dc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.openarchives.org/OAI/2.0/oai_dc/ http://www.openarchives.org/OAI/2.0/oai_dc.xsd"><identifier>ir-10054-1647</identifier><datestamp>2011-12-15T09:57:52Z</datestamp><dc:title>AHIR: a hardware intermediate representation for hardware generation from high-level programs</dc:title><dc:creator>SAHASRABUDDHE, SAMEER D</dc:creator><dc:creator>RAJA, HAKIM</dc:creator><dc:creator>ARYA, KAVI</dc:creator><dc:creator>DESAI, MP</dc:creator><dc:subject>application specific integrated circuits</dc:subject><dc:subject>hardware-software codesign</dc:subject><dc:subject>logic design</dc:subject><dc:subject>program compilers</dc:subject><dc:description>We present AHIR, an intermediate representation (IR), that acts as a transition layer between software compilation and hardware synthesis. Such a transition layer is intended to take advantage of optimisations available in the software compiler flow, and also to provide freedom to the low-level synthesiser, to explore options for application-specific implementations. Two operations become possible - reuse of computational resources across different modules in the design, and generation of an application-specific memory subsystem for faster data accesses. AHIR presents a decoupled view of the program, in terms of control flow, dataflow and memory accesses. Each module in AHIR is a triplet consisting of a control-path, datapath and a symbolic association between the two. Memory is represented only by load-store operators, while the memory subsystem is separately designed by the implementor. In the program-to-hardware flow, a module in AHIR corresponds to a function in C. A complete program is a call-graph of functions, which is translated to a set of modules. The call-graph is restricted to be a DAG; recursion is not allowed. The representation is generated by a back-end in the software compiler, which runs after all source-level optimisations have been performed by relevant passes.</dc:description><dc:publisher>IEEE</dc:publisher><dc:date>2009-09-19T07:16:06Z</dc:date><dc:date>2011-11-28T08:52:03Z</dc:date><dc:date>2011-12-15T09:57:52Z</dc:date><dc:date>2009-09-19T07:16:06Z</dc:date><dc:date>2011-11-28T08:52:03Z</dc:date><dc:date>2011-12-15T09:57:52Z</dc:date><dc:date>2007</dc:date><dc:type>Article</dc:type><dc:identifier>Proceedings of the 20th International Conference on VLSI Design held jointly with 6th International Conference on Embedded Systems, Bangalore, India, 6-10 January 2007, 245-250</dc:identifier><dc:identifier>0-7695-2762-0</dc:identifier><dc:identifier>10.1109/VLSID.2007.28</dc:identifier><dc:identifier>http://hdl.handle.net/10054/1647</dc:identifier><dc:identifier>http://dspace.library.iitb.ac.in/xmlui/handle/10054/1647</dc:identifier><dc:language>en</dc:language></oai_dc:dc>