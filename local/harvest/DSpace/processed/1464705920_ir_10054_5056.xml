<oai_dc:dc xmlns:oai_dc="http://www.openarchives.org/OAI/2.0/oai_dc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.openarchives.org/OAI/2.0/oai_dc/ http://www.openarchives.org/OAI/2.0/oai_dc.xsd"><identifier>ir-10054-5056</identifier><datestamp>2011-12-27T05:36:56Z</datestamp><dc:title>E-path_PRE - Partial redundancy elimination made. easy</dc:title><dc:creator>DHAMDHERE, DM</dc:creator><dc:subject>data-flow-analysis</dc:subject><dc:subject>strength reduction transformation</dc:subject><dc:subject>global program optimization</dc:subject><dc:subject>edge placement</dc:subject><dc:subject>code motion</dc:subject><dc:subject>algorithm</dc:subject><dc:subject>reality</dc:subject><dc:subject>partial redundancy elimination</dc:subject><dc:subject>eliminatability of expressions</dc:subject><dc:subject>code optimization</dc:subject><dc:subject>data flow analysis</dc:subject><dc:subject>redundant code movement</dc:subject><dc:description>Partial redundancy elimination (PRE) subsumes the classical optimizations of loop invariant movement and common subexpression elimination. The original formulation of PRE involved complex bi-directional data flows and had two major deficiencies-missed optimization opportunities and redundant code movement. To eliminate redundant code movement, most current PRE approaches use a hoisting-followed-by-sinking approach. Unfortunately, this approach has a high conceptual complexity and requires complicated correctness proofs. We show that optimization by partial redundancy elimination is simpler than it has been made out to be. Its essence is the concept of eliminatability of an expression. We show that E-path_PRE, a formulation of PRE based on the concept of eliminatability paths (E-paths), is easy to understand and simple to prove correct. It uses only well-known data flow concepts of available expressions and anticipatable (i.e. very-busy) expressions to directly identify code insertion points which avoid redundant code movement. These features reduce the conceptual complexity of PRE considerably. Interestingly, performance studies show that E-path_PRE is also less expensive to perform than the closest equivalent approach to PRE. This is a sheer bonus.</dc:description><dc:publisher>ASSOC COMPUTING MACHINERY</dc:publisher><dc:date>2011-07-18T20:30:44Z</dc:date><dc:date>2011-12-26T12:50:49Z</dc:date><dc:date>2011-12-27T05:36:56Z</dc:date><dc:date>2011-07-18T20:30:44Z</dc:date><dc:date>2011-12-26T12:50:49Z</dc:date><dc:date>2011-12-27T05:36:56Z</dc:date><dc:date>2002</dc:date><dc:type>Article</dc:type><dc:identifier>ACM SIGPLAN NOTICES, 37(8), 53-65</dc:identifier><dc:identifier>0362-1340</dc:identifier><dc:identifier>http://dx.doi.org/10.1145/596992.597004</dc:identifier><dc:identifier>http://dspace.library.iitb.ac.in/xmlui/handle/10054/5056</dc:identifier><dc:identifier>http://hdl.handle.net/10054/5056</dc:identifier><dc:language>en</dc:language></oai_dc:dc>